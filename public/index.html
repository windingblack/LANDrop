<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> -->
  <title>LANDrop</title>
  <link href="/css/tailwind.min.css" rel="stylesheet" />
  <script src="/socket.io/socket.io.js"></script>
  <style>
    html, body, #messages {
      height: 100%;
      margin: 0;
    }
    body {
      display: flex;
      flex-direction: column;
      background-color: #f3f4f6; /* Tailwind gray-100 */
      touch-action: pan-x pan-y;
    }
    header {
      flex: 0 0 50px;
      color: white;
      font-weight: 600;
      display: flex;
      align-items: center;
      padding-left: 1rem;
      font-size: 1.25rem;
    }
    
    button:hover {
      cursor: pointer;
    }

    #messages {
      flex: 1 1 auto;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    #form {
      flex: 0 0 auto;
      background: rgba(255,255,255,0);
      padding: 0.5rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #form button {
        margin-top: 6px;
    }
    textarea {
      resize: none;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      padding: 0.5rem;
      font-size: 1rem;
    }
    #uploadBtn {
        margin-right:10px;
    }
    .chat-bubble {
      background-color: #e5e7eb; /* Tailwind gray-200 */
      color: black;
      padding: 0.5rem 0.75rem;
      border-radius: 1rem;
      max-width: 80%;
      font-size: 1.5rem;
      display: inline-block;
      word-break: break-word;
    }
    .chat-time {
      font-size: 1.25rem;
      color: #6b7280; /* Tailwind gray-500 */
      margin-bottom: 0.25rem;
    }
    .img-thumb {
      width: 120px;
      height: auto;
      border-radius: 0.5rem;
      transition: transform 0.2s;
    }
    .img-thumb:hover {
      cursor: zoom-in;
      transform: scale(1.1);
    }
    .image-wrapper {
      position: relative;
      display: inline-block;
    }
    .image-wrapper::after {
      content: "\1F50D";
      font-size: 1.5rem;
      position: absolute;
      right: 0.25rem;
      bottom: 0.25rem;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .image-wrapper:hover::after {
      opacity: 1;
    }
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .modal-overlay.active {
      display: flex;
    }
    .modal-overlay img {
      max-width: 90%;
      max-height: 90%;
      cursor: zoom-out;
      border-radius: 0.5rem;
    }
  </style>
  <style>
    .loader {
        border-top-color: #10b981; /* green */
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        to {
        transform: rotate(360deg);
        }
    }
  </style>
  <style>
    .progress-wrapper {
        transition: opacity 0.5s ease, transform 0.5s ease;
    }
    .progress-wrapper.hidden {
        opacity: 0;
        transform: translateY(-10px);
    }
    /* æ¼‚ç§»æ¶ˆå¤±åŠ¨ç”» */
    @keyframes floatOut {
        0% {
            transform: translateY(0);
            opacity: 1;
        }
        100% {
            transform: translateY(-40px);
            opacity: 0;
        }
    }

    .floating-progress {
        position: fixed;
        z-index: 9999;
        animation: floatOut 0.8s linear forwards;
        pointer-events: none;
    }
  </style>
</head>
<div id="loadingOverlay" class="fixed inset-0 flex items-center justify-center z-50 hidden">
  <div class="loader border-4 border-white border-t-green-500 rounded-full w-12 h-12 animate-spin"></div>
</div>
<body>
  <header class="bg-blue-500" >LANDrop</header>
  <main id="messages"></main>
  <form id="form">
    <textarea id="input" rows="3" placeholder="Type a message..."></textarea>
    <div class="flex justify-end gap-2">
      <input type="file" id="fileInput" class="hidden" accept="*/*" multiple />
      <button type="button" id="uploadBtn" class="text-blue-500 text-m" title="Upload file">ğŸ”—</button>
      <button type="submit" class="bg-blue-500 text-white rounded px-3 py-1">Send</button>
    </div>
  </form>
  <div id="progressArea" class="space-y-2 shadow"></div>

  <div id="imageModal" class="modal-overlay" onclick="closeModal()">
    <img id="modalImage" src="" alt="preview" />
  </div>

  <script>
    const socket = io();
    const form = document.getElementById('form');
    const input = document.getElementById('input');
    const messages = document.getElementById('messages');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const imageModal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');

    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    /**Start Notification Start**/
    function showToast(message, duration = 2000) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.remove('hidden');
        toast.classList.add('opacity-100');

        setTimeout(() => {
            toast.classList.remove('opacity-100');
            setTimeout(() => toast.classList.add('hidden'), 300);
        }, duration);
    }

    /**End Notification End**/

    /**Start åŠ è½½æ¶ˆæ¯ Start**/
    function renderFileMessage(msg) {
        const container = document.createElement('div');
        container.className = 'chat-bubble';

        if (msg.deleted) {
            container.innerHTML = `<span class="line-through text-gray-500">${msg.filename}</span>`;
        } else {
            container.innerHTML = `
            <a href="/file/${msg.content}" class="text-blue-600 underline mr-2" target="_blank">${msg.filename}</a>
            <button class="delete-btn text-red-500" title="Delete File">ğŸ—‘</button>
            `;
            const deleteBtn = container.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to delete this file?')) {
                    fetch(`/delete/${msg.id}`, { method: 'POST' })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            // å¯åˆ·æ–°å•æ¡æ¶ˆæ¯æˆ–æ•´ä½“åˆ·æ–°
                            container.innerHTML = `<span class="line-through text-gray-500">${msg.filename}</span>`;
                            showToast("Successfully deleted", 1000)
                        } else {
                            alert('Failed to delete the file.');
                        }
                    });
                }
            });
        }

        return container;
    }

    function buildMessage(message) {
        const item = document.createElement('div');
        const { time, type, content, filename } = message;
        const timeStr = new Date(time).toLocaleString();

        item.innerHTML = `<div class="chat-time">${timeStr}</div>`;

        if (type === 'text') {
            item.innerHTML += `<div class="chat-bubble">${linkify(escapeHtml(content))}</div>`;
        } else if (type === 'image') {
            item.innerHTML += `
            <div class="image-wrapper">
                <img src="/file/${content}" class="img-thumb preview-img" data-src="/file/${content}">
            </div>`;
        } else if (type === 'file') {
            item.appendChild(renderFileMessage(message));
        }
        
        return item;
    }

    function addMessage(message) {
        const item = buildMessage(message);
        messages.appendChild(item); // æ’å…¥åˆ°åº•éƒ¨
        setTimeout(() => {
            messages.scrollTop = messages.scrollHeight;
        }, 0);

        item.querySelectorAll('.preview-img').forEach(img => {
            img.onclick = () => openModal(img.dataset.src);
        });
    }

    function addMessageBatch(msgs, toTop = false) {
        if (toTop) {
            const oldScrollHeight = messages.scrollHeight;
            items = msgs.reverse().map(msg => buildMessage(msg));
            items.forEach(item => attachItem(messages.prepend.bind(messages), item)); // æ’å…¥åˆ°é¡¶éƒ¨
            // ä¿æŒæ»šåŠ¨ä½ç½®ç›¸å¯¹ä¸åŠ¨ï¼ˆå³ä»æ˜¾ç¤ºåˆšåˆšåŠ è½½å‡ºçš„æœ€åä¸€æ¡ï¼‰
            setTimeout(() => {
                setTimeout(() => {
                    const newScrollHeight = messages.scrollHeight;
                    messages.scrollTop += newScrollHeight - oldScrollHeight;
                }, 0);
            }, 0);
        } else {
            messages.innerHTML = '';
            items = msgs.map(msg => buildMessage(msg))
            items.forEach(item => attachItem(messages.appendChild.bind(messages), item)); // æ’å…¥åˆ°åº•éƒ¨
            setTimeout(() => {
                messages.scrollTop = messages.scrollHeight;
            }, 0);
        }
    }

    function attachItem(attach, item) {
        attach(item);

        item.querySelectorAll('.preview-img').forEach(img => {
            img.onclick = () => openModal(img.dataset.src);
        });
    }

    function linkify(text) {
        const urlRegex = /(https?:\/\/[^\s]+)/g;

        return text.replace(urlRegex, function(url) {
            const escapedUrl = url.replace(/"/g, '&quot;'); // é˜²æ­¢å±æ€§æ³¨å…¥
            return `<a href="${escapedUrl}" target="_blank" class="text-blue-500 underline">${url}</a>`;
        });
    }


    socket.on('chat message', (msg) => addMessage(msg));

    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const val = input.value.trim();
      if (val) {
        socket.emit('chat message', val);
        input.value = '';
      }
    });
    /**End åŠ è½½æ¶ˆæ¯ End**/

    /**Start Draw loading animation Start**/
    function showLoading() {
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }
    function hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }
    /**End Draw loading animation End**/

    /**Start æ»šåŠ¨ç›‘å¬ï¼Œæ¥è¿‘é¡¶éƒ¨åŠ è½½æ›´å¤šæ¶ˆæ¯ Start**/
    let isLoading = false;
    let isAllLoaded = false;

    function scrollLoad() {
        messages.addEventListener('scroll', () => {
            if (isLoading || isAllLoaded) return;

            if (messages.scrollTop < 50) {  // æ¥è¿‘é¡¶éƒ¨
                isLoading = true;
                showLoading();

                loadMessages().then(() => {
                // ä¿æŒæ»šåŠ¨ä½ç½®ä¸å˜ï¼ˆé˜²æ­¢è·³åŠ¨ï¼‰
                    messages.scrollTop = 50;
                    isLoading = false;
                    hideLoading();
                });
            }
        });
    }
    /**End æ»šåŠ¨ç›‘å¬ï¼Œæ¥è¿‘é¡¶éƒ¨åŠ è½½æ›´å¤šæ¶ˆæ¯**/

    /**Start é¡µé¢åˆå§‹åŒ–æ—¶è¯·æ±‚æœ€æ–°ä¸€é¡µæ¶ˆæ¯ Start**/
    let offset = 0;

    //resetï¼šåˆ†é¡µæ˜¯å¦ç¬¬ä¸€é¡µ
    async function loadMessages(reset = false) {
        const res = await fetch(`/messages?offset=${offset}`);
        if (!res.ok) {
            alert('Failed to load messages.');
            return;
        }

        const data = await res.json();

        addMessageBatch(data.messages, !reset);  // ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºæ’å…¥åˆ°é¡¶éƒ¨

        offset += data.messages.length;

        // å¦‚æœæ¶ˆæ¯æ€»æ•° <= å½“å‰åŠ è½½æ•°ï¼Œè¯´æ˜å·²ç»åŠ è½½å®Œäº†
        if (offset >= data.total) {
            isAllLoaded = true;
        }

        if (reset) {
            scrollLoad();
        }
    }

    loadMessages(true);
    /**End é¡µé¢åˆå§‹åŒ–æ—¶è¯·æ±‚æœ€æ–°ä¸€é¡µæ¶ˆæ¯ End**/

    /**Start æ–‡ä»¶/å›¾ç‰‡ä¸Šä¼  Start**/
    uploadBtn.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', () => {
        const files = fileInput.files;
        if (!files.length) return;

        for (let file of files) {
            uploadFile(file);
        }
    });

    const progressArea = document.getElementById('progressArea');

    function uploadFile(file) {
        const formData = new FormData();
        formData.append('fileData', file);

        // åˆ›å»ºè¿›åº¦æ¡å…ƒç´ 
        const wrapper = document.createElement('div');
        wrapper.className = 'progress-wrapper relative bg-gray-300 rounded overflow-hidden h-6 mt-2 shadow';

        const bar = document.createElement('div');
        bar.className = 'bg-green-500 h-full w-0 transition-all duration-300';
        wrapper.appendChild(bar);

        const fileName = document.createElement('span');
        fileName.className = 'absolute left-1/2 top-1/2 text-white text-xs transform -translate-x-1/2 -translate-y-1/2 whitespace-nowrap';
        fileName.textContent = file.name;
        wrapper.appendChild(fileName);

        const cancelBtn = document.createElement('button');
        cancelBtn.innerHTML = 'âœ–';
        cancelBtn.className = 'absolute right-2 top-1/2 transform -translate-y-1/2 text-white text-lg';
        wrapper.appendChild(cancelBtn);

        progressArea.appendChild(wrapper);

        // ä¸Šä¼ é€»è¾‘
        const xhr = new XMLHttpRequest();

        cancelBtn.onclick = () => {
            xhr.abort();
            fadeOut(wrapper);
            fileInput.value = ''; // æ¸…ç©ºå·²é€‰æ–‡ä»¶
        };

        xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
                const percent = (e.loaded / e.total) * 100;
                bar.style.width = `${percent}%`;
            }
        };

        xhr.onload = () => {
            fileName.textContent = 'âœ… Successfully uploaded';
            setTimeout(() => fadeOut(wrapper), 1000);
        };

        xhr.onerror = () => {
            fileName.textContent = 'âŒ Failed to upload file';
            setTimeout(() => fadeOut(wrapper), 1000);
            fileInput.value = ''; // æ¸…ç©ºå·²é€‰æ–‡ä»¶
        };

        xhr.open('POST', '/upload');
        xhr.send(formData);
    }

    // â­ åŠ¨ç”»æµ®å‡ºå¹¶ç§»é™¤
    function fadeOut(wrapper) {
        // è·å–ä½ç½®å’Œå°ºå¯¸
        const rect = wrapper.getBoundingClientRect();

        // å…‹éš† DOM
        const clone = wrapper.cloneNode(true);
        clone.classList.add('floating-progress');
        clone.style.left = rect.left + 'px';
        clone.style.top = rect.top + 'px';
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';

        // åŠ åˆ° bodyï¼Œç«‹å³ä»åŸåœ° remove
        document.body.appendChild(clone);
        wrapper.remove();

        // åŠ¨ç”»ç»“æŸå†å½»åº•é”€æ¯ clone
        clone.addEventListener('animationend', () => clone.remove());
    }


    /**End æ–‡ä»¶/å›¾ç‰‡ä¸Šä¼  End**/

    /**Start å›¾ç‰‡é¢„è§ˆ Start**/
    function openModal(src) {
      modalImage.src = src;
      imageModal.classList.add('active');
    }

    function closeModal() {
      imageModal.classList.remove('active');
      modalImage.src = '';
    }

    //åŒæŒ‡åŒæ—¶ç¼©æ”¾ + æ‹–åŠ¨çš„é€»è¾‘
    let initialDistance = 0;
    let lastScale = 1;
    let currentScale = 1;

    let startMidpoint = { x: 0, y: 0 };
    let currentTranslate = { x: 0, y: 0 };
    let lastTranslate = { x: 0, y: 0 };

    let lastTapTime = 0;

    function getMidpoint(t1, t2) {
        return {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };
    }

    function updateTransform() {
        modalImage.style.transform = `translate(${currentTranslate.x}px, ${currentTranslate.y}px) scale(${currentScale})`;
    }

    function resetImageTransform() {
        currentScale = 1;
        currentTranslate = { x: 0, y: 0 };
        lastTranslate = { x: 0, y: 0 };
        modalImage.style.transition = 'transform 0.3s ease';
        updateTransform();
        setTimeout(() => modalImage.style.transition = '', 300);
    }

    imageModal.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            const [t1, t2] = e.touches;
            initialDistance = Math.hypot(
                t2.clientX - t1.clientX,
                t2.clientY - t1.clientY
            );
            startMidpoint = getMidpoint(t1, t2);
            lastScale = currentScale;

            // è®¾ç½® transform-origin ä¸ºä¸­ç‚¹
            const rect = modalImage.getBoundingClientRect();
            const offsetX = ((startMidpoint.x - rect.left) / rect.width) * 100;
            const offsetY = ((startMidpoint.y - rect.top) / rect.height) * 100;
            modalImage.style.transformOrigin = `${offsetX}% ${offsetY}%`;
        }
    });

    imageModal.addEventListener('touchmove', e => {
        if (e.touches.length === 2) {
            const [t1, t2] = e.touches;
            const newDistance = Math.hypot(
                t2.clientX - t1.clientX,
                t2.clientY - t1.clientY
            );
            const newMidpoint = getMidpoint(t1, t2);

            // ç¼©æ”¾è®¡ç®—
            const scaleFactor = newDistance / initialDistance;
            currentScale = Math.min(Math.max(lastScale * scaleFactor, 1), 4);

            // æ‹–åŠ¨è®¡ç®—ï¼ˆåŒæŒ‡ç§»åŠ¨çš„ä¸­ç‚¹åç§»ï¼‰
            currentTranslate.x = lastTranslate.x + (newMidpoint.x - startMidpoint.x);
            currentTranslate.y = lastTranslate.y + (newMidpoint.y - startMidpoint.y);

            updateTransform();
            e.preventDefault();
        }
    });

    imageModal.addEventListener('touchend', e => {
        const now = Date.now();
        if (now - lastTapTime < 300) {
            resetImageTransform();
        }
        lastTapTime = now;

        if (e.touches.length < 2) {
            lastTranslate = { ...currentTranslate };
            initialDistance = 0;
        }
    });
    /**End å›¾ç‰‡é¢„è§ˆ End**/

    /**Start é•¿æŒ‰é€‰ä¸­æ¶ˆæ¯çš„å…¨éƒ¨å†…å®¹ Start**/
    let timer = null;

    messages.addEventListener('touchstart', (e) => {
        const target = e.target.closest('.chat-bubble');
        if (!target) return;

        timer = setTimeout(() => {
            selectElementText(target);
        }, 500);
    });

    messages.addEventListener('touchend', () => clearTimeout(timer));
    messages.addEventListener('touchmove', () => clearTimeout(timer));

    function selectElementText(el) {
        if (window.getSelection && document.createRange) {
            const selection = window.getSelection();
            const range = document.createRange();
            selection.removeAllRanges();
            range.selectNodeContents(el);
            selection.addRange(range);
        }
    }
    /**End é•¿æŒ‰é€‰ä¸­æ¶ˆæ¯çš„å…¨éƒ¨å†…å®¹ End**/

    const textarea = document.getElementById('input');

    textarea.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();  // é˜»æ­¢æ¢è¡Œ
            document.querySelector('#form button[type="submit"]').click();
        }
    });

  </script>
</body>
<div id="toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg opacity-0 pointer-events-none transition-opacity duration-300 z-50 hidden"></div>
</html>
